---
title: "Esercizio 2"
author: "Simone Gervasoni"
date: "2024-01-05"
output:
  html_document:
    theme: paper
  word_document: default
  pdf_document: default
---

### (a) Libreria Heatmaply
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Una heat map è un modo per visualizzare dati con molteplici dimensioni attraverso l'uso di celle colorate che rappresentano specifici numeri. La libreria *heatmaply* ci consente di fare heatmaps interattive.
Queste heat maps sono interattive dato che passando il cursore sopra le celle viene mostrato il valore della cella stessa e un click consente lo zoom del grafico. \ Prima di procedere ad un esempio assicuriamoci di aver installato il pacchetto *heatmaply* e importiamo tutte le librerie necessarie: 

```{r message= F , warning= F}
library("heatmaply") 
library("tidyverse")
```
Esploriamo dunque le 4 aree nelle quali ci possiamo servire della libreria *heatmaply*: \ 
1. Controllare e confrontare valori. \ 
2. Ordinare in base al cluster e fare dendrogrammi. \ 
3. Visualizzare correlazioni. \ 
4. Visualizzare la frequenza e l'ubicazione dei valori mancanti.


#### (1) Controllare e confrontare valori
Facciamo dunque un esempio usando il dataset Iris che contiene i dati delle misure in centimetri della lunghezza e largezza dei petali e sepali. Escludendo la specie, la tabella risulta essere quadridimensionale con queste colonne : `Sepal.Length`,`Sepal.Width`, `Petal.Length`, `Petal.Width`. Quindi possiamo farci un idea di come è fatto il dataset visualizzando l'heat map con il seguente codice:

```{r}
set.seed(500) # fissiamo il seed per avere un sample sempre uguale
p <- iris %>%
  sample_n(size=30) %>% 
  #prendiamo un sotto insieme piccolo per miglior visualizzazione
  select(-Species) 
  #togliamo la variabile specie
  p%>%
  heatmaply(Rowv=NA,Colv = NA,
  ylab = "id_oss",
  xlab = "variabili",
  main = "Dati Iris")
```
Da questo grafico possiamo trarre delle conclusioni sulla variabilità delle colonne, ad esempio che `Petal.Length` sembra essere la più variabile mentre `Sepal.Width`sembra essere la meno variabile.
Inoltre è possibile evicere per ogni singola collona una media approssimativa.

Questo tipo di grafico risulta molto più efficacie quando, come in questo caso, le osservazioni hanno lo stesso ordine di grandezza e la stessa unità di misura.

#### (2) Ordinare in base al cluster e fare dendrogrammi

Come sappiamo le osservazione del dataset `iris` hanno un'ultima colonna `species` con 3 modalità (cioè la specie a cui appartengono), dunque heamaply fa cluster automaticamente e ponendo `k=3` coloriamo i rami del dendrogramma con 3 colori diversi.

```{r}
  p %>%
  heatmaply(Colv = NA,
  k_row = 3,
  ylab = "id_oss",
  xlab = "variabili",
  main = "Dati Iris")  #Le ultime 3 righe risultano utili per abbellire il grafico con titolo principale e degli assi
```
Togliendo `Colv = NA` potremmo anche fare un dendrogramma delle colonne che in questo caso avrebbe poco senso.
Da questo grafico possiamo notare molteplici cose: \ 
1. Il gruppo rosso ha i petali più piccoli e meno spessi e i sepali più piccoli. \  
2. Del gruppo blu possiamo dire il contrario. \ 
3. Il gruppo verde sembra essere una via di mezzo ma è più simile al blu.


#### (3) Visualizzare correlazioni 
Visualizziamo le correlazioni tra le varie colonne utilizzando `heatmaply_cor` che si avvale di `heatmaply` ma è ottimizzato per agire su matrici di correlazione. Il comando `heatmaply_cor(cellnote = cor(iris%>%select(-Species)))` serve per scrivere sopra alla tabella in modo chiaro, mentre `ggplot2::scale_fill_gradient2` serve per impostare il gradiente dei colori da -1 (blue) a 1 (rosso). 

```{r}
  p %>%
  cor() %>%
  heatmaply_cor(cellnote = cor(iris%>%
  select(-Species)), scale_fill_gradient_fun = ggplot2::scale_fill_gradient2(
  low = "blue", 
  high = "red", 
  midpoint = 0, 
  limits = c(-1, 1)
),
  ylab = "variabili",
  xlab = "variabili",
  main = "Dati Iris: Correlazione tra variabili"
) 
```
Questo grafico rende immediatamente evidente la correlazione tra lo spessore e la lunghezza del petalo tramite un giusto uso dei colori.

#### (4) Visualizzare NAs 
In primo luogo generiamo generiamo una tabella con `NA` randomici,
poi Visualizziamo gli NAs attraverso la funzione `heatmaply_na` che si avvale di `heatmaply`.

```{r}
  set.seed(431)
  n<- nrow(p)
  p %>%
  mutate(Sepal.Width = ifelse( runif(n) < 0.1  , NA,Sepal.Width), 
  Sepal.Length = ifelse( runif(n) < 0.1  , NA,Sepal.Length),
  Petal.Length = ifelse( runif(n) < 0.1  , NA ,Petal.Length),
  Petal.Width = ifelse( runif(n) < 0.1 , NA ,Petal.Width)) %>% # inseriamo il 10 percento di NA
  heatmaply_na( ylab = "id_oss",
  xlab = "variabili",
  main = "Dati Iris: Presenza di NA",
  Rowv=NA,Colv = NA,
  )
    

```

Da questo grafico riusciamo a capire la frequenza e l'ubicazione degli `NA`.



## (b) Applicazione 

Applichiamo questa libreria al tibble gapminder un tibble che riporta i dati sul PIL, la popolosità, e l'aspettativa media di vita per diversi paesi. Noi ci concentreremo in particolare in Asia nel 2007. Usando la funzione `percentize()` ogni osservazione viene divisa per il massimo della propria colonna, così perdiamo delle informazioni (i valori assoluti della variabili), ma riusciamo ad ottenere una maggiore leggibilità della heatmap.

```{r}

library(gapminder)
asia_data <- gapminder %>%
  filter(continent == "Asia")

asia_data %>%
  filter(year==2007) %>%
  column_to_rownames(var="country")%>%
  select(lifeExp, gdpPercap, pop)%>% 
  #mettiamo life_exp e gdppercap vicini
  percentize() %>%
  heatmaply(Colv = NA,
  k_row =  3,
  ylab = "Nazioni",
  xlab = "Variabili",
  main = "Dati Asia 2007")
```
Da questo grafico possiamo evincere che `lifeExp` è molto correlato a `gdpPercap` e lievemente negativamente correlato con `pop`. Anche in questo caso è abbastanza chiaro che il dasest sia divisibile in 3 cluster, certamente quello più distinto è il cluster rosso di paesi asiatici già fortemente industrializzati e relativamente poco popolosi, quali il Giappone, Hong Kong, Singapore. 

### Evoluzione dell'aspettativa di vita
Un uso improprio potrebbe essere quello di creare un dataset in formato wide che ha come `key=year` e come value `value=lifeExp`. Questo crea una matrice che ha come colonne gli anni e come righe i nomi dei paesi e dentro le celle l'aspettativa di vita in quell'anno di quel determinato paese. 

```{r}
library(gapminder)
subset_data_2 <- asia_data %>%
  select(country,lifeExp, year) %>%
  group_by(country)%>%
  spread(key= year, value= lifeExp)%>%
  column_to_rownames(var="country")

subset_data_2 %>%
  heatmaply(Colv = NA,
  ylab = "Nazioni",
  xlab = "Anni",
  main = "Aspettativa di vita in Asia da 1952 a 2007")
```
Da questo grafico risulta chiaro come con l'avanzare degli anni si migliorano le aspettative di vita. Inoltre si possono osservare gli effetto eventi storici come il genocidio cambogiano o la guerre del golfo. 

### Correlazione con aspettativa di vita
Ora visualizziamo la correlazione tra l'aspettiva di vita e altre variabili.

```{r}
asia_data %>%
  select(lifeExp, gdpPercap, year, pop) %>% 
  cor() %>% # correlazione tra diverse variabili 
  # in asia dal 1952 al 2007
  heatmaply_cor(Rowv=NA,Colv = NA, scale_fill_gradient_fun = ggplot2::scale_fill_gradient2(
  low = "blue", 
  high = "red", 
  midpoint = 0, 
  limits = c(-1, 1) 
),
  ylab = "Variabili",
  xlab = "Variabili",
  main = "Correlazione tra aspettativa di vita e altre variabili")
```
Come avevamo predetto le variabili `year` e `gdpPercap` sono molto correlate con l'aspettativa di vita.
